class Payment < ApplicationRecord
  # Polymorphic association - can be attached to ANY business model
  # Examples: Order (has_one), Subscription (has_many), Booking, Course, etc.
  belongs_to :payable, polymorphic: true, optional: true
<% if @auth -%>
  belongs_to :user, optional: true
  # CLACKY_NOTE: User is optional to support:
  # - Normal case: payment.user == payable.user (most common)
  # - Gift/proxy payment: payment.user != payable.user (payer differs from recipient)
  # - Anonymous: payment.user = nil, uses customer_email instead
<% else -%>
  validates :customer_email, presence: true, format: { with: URI::MailTo::EMAIL_REGEXP }
<% end -%>

  # Core Stripe validations (DO NOT remove these)
  validates :amount, presence: true, numericality: { greater_than: 0 }
  validates :currency, presence: true
  validates :status, presence: true, inclusion: { in: %w[pending processing paid failed canceled refunded] }

  # Scopes
  scope :pending, -> { where(status: 'pending') }
  scope :processing, -> { where(status: 'processing') }
  scope :paid, -> { where(status: 'paid') }
  scope :failed, -> { where(status: 'failed') }
  scope :canceled, -> { where(status: 'canceled') }
  scope :refunded, -> { where(status: 'refunded') }
  scope :recent, -> { order(created_at: :desc) }

  # Status check methods
  def pending?
    status == 'pending'
  end

  def processing?
    status == 'processing'
  end

  def paid?
    status == 'paid'
  end

  alias_method :succeeded?, :paid?

  def failed?
    status == 'failed'
  end

  def canceled?
    status == 'canceled'
  end

  def refunded?
    status == 'refunded'
  end

  def completed?
    paid?
  end

  # Status transitions
  def mark_as_processing!
    update!(status: 'processing')
  end

  def mark_as_paid!
    update!(status: 'paid')
  end

  def mark_as_failed!
    update!(status: 'failed')
  end

  def mark_as_canceled!
    update!(status: 'canceled')
  end

  def mark_as_refunded!
    update!(status: 'refunded')
  end

  # Customer information - delegates to user or payable
  def customer_name
<% if @auth -%>
    return user.name if user&.respond_to?(:name) && user.name.present?
    return "#{user.first_name} #{user.last_name}".strip if user&.respond_to?(:first_name)
    return user.email.split('@').first if user&.email
<% end -%>
    payable&.respond_to?(:customer_name) ? payable.customer_name : 'Unknown'
  end

  def customer_email
<% if @auth -%>
    user&.email || (payable&.respond_to?(:customer_email) ? payable.customer_email : nil)
<% else -%>
    super || (payable&.respond_to?(:customer_email) ? payable.customer_email : nil)
<% end -%>
  end

  # Product description for Stripe checkout
  # Payable object should implement payment_description method
  def product_description
    if payable&.respond_to?(:payment_description)
      payable.payment_description
    elsif payable&.respond_to?(:name)
      payable.name
    elsif payable&.respond_to?(:title)
      payable.title
    else
      "Payment for #{payable_type} ##{payable_id}"
    end
  end

  # Amount helpers
  def amount_in_cents
    (amount * 100).to_i
  end

  def formatted_amount
    "#{currency.upcase} #{sprintf('%.2f', amount)}"
  end

  def display_status
    status.humanize
  end

  # Stripe helpers
  def has_stripe_payment_intent?
    stripe_payment_intent_id.present?
  end

  def has_stripe_checkout_session?
    stripe_checkout_session_id.present?
  end

  def subscription_payment?
    payable&.respond_to?(:stripe_mode) && payable.stripe_mode == 'subscription'
  end

  def summary
    "#{product_description} - #{customer_name} (#{formatted_amount}) - #{display_status}"
  end

  default_scope { order(created_at: :desc) }
end
