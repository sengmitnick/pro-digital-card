class StripePaymentService < ApplicationService
  include Rails.application.routes.url_helpers
  attr_reader :payment, :checkout_session

  def initialize(payment, request = nil)
    @payment = payment
    @request = request
  end

  def call
    create_checkout_session
  end

  # Create Checkout Session for Stripe
  def create_checkout_session
    # Check if payment is in valid state
    unless payment.pending? || payment.failed? || payment.processing?
      return { success: false, error: "Payment is not in a valid state (current status: #{payment.status})" }
    end

    begin
      @checkout_session = Stripe::Checkout::Session.create(
        payment_method_types: ['card'],
        line_items: build_line_items,
        mode: payment_mode,
        customer_email: payment.customer_email,
        success_url: success_payment_url(payment, only_path: false),
        cancel_url: failure_payment_url(payment, only_path: false),
        metadata: build_metadata
      )

      # Update payment with checkout session ID
      payment.update!(
        stripe_checkout_session_id: @checkout_session.id,
        status: 'processing'
      )

      { success: true, checkout_session: @checkout_session }
    rescue Stripe::StripeError => e
      payment.mark_as_failed!
      { success: false, error: e.message }
    end
  end

  # Process webhook events from Stripe
  def self.process_webhook_event(event)
    case event['type']
    when 'checkout.session.completed'
      handle_checkout_success(event['data']['object'])
    when 'checkout.session.expired'
      handle_checkout_expiration(event['data']['object'])
    when 'payment_intent.succeeded'
      handle_payment_success(event['data']['object'])
    when 'payment_intent.payment_failed'
      handle_payment_failure(event['data']['object'])
    when 'payment_intent.canceled'
      handle_payment_cancellation(event['data']['object'])
    when 'invoice.payment_succeeded'
      handle_invoice_payment_success(event['data']['object'])
    when 'customer.subscription.created', 'customer.subscription.updated'
      handle_subscription_update(event['data']['object'])
    when 'customer.subscription.deleted'
      handle_subscription_deleted(event['data']['object'])
    else
      Rails.logger.info "Unhandled event type: #{event['type']}"
    end
  end

  # Sync payment status from Stripe (for development)
  def self.sync_payment_status(payment)
    return unless payment&.stripe_checkout_session_id&.present?
    return if payment.paid?

    begin
      if payment.stripe_checkout_session_id.start_with?('cs_')
        session = Stripe::Checkout::Session.retrieve(payment.stripe_checkout_session_id)
        if session.payment_status == 'paid'
          payment.mark_as_paid!
          process_payment_paid(payment)
          Rails.logger.info "Development: Synced payment #{payment.id} to paid status"
        end
      elsif payment.stripe_payment_intent_id.present?
        payment_intent = Stripe::PaymentIntent.retrieve(payment.stripe_payment_intent_id)
        if payment_intent.status == 'succeeded'
          payment.mark_as_paid!
          process_payment_paid(payment)
          Rails.logger.info "Development: Synced payment #{payment.id} to paid status"
        end
      end
    rescue Stripe::StripeError => e
      Rails.logger.error "Development: Failed to sync payment #{payment.id}: #{e.message}"
    end
  end

  private

  # Build line items for Stripe checkout
  #
  # Default: Uses payment amount for one-time purchases (works out of the box)
  #
  # For subscriptions: Implement stripe_line_items in your payable model
  # Example (dynamic creation - no Stripe Dashboard setup needed):
  #   def stripe_line_items
  #     [{
  #       price_data: {
  #         currency: 'usd',
  #         product_data: { name: plan_name },
  #         unit_amount: (plan_price * 100).to_i,  # dollars to cents
  #         recurring: { interval: 'month' }        # for subscriptions
  #       },
  #       quantity: 1
  #     }]
  #   end
  def build_line_items
    line_items = if payment.payable.respond_to?(:stripe_line_items)
      payment.payable.stripe_line_items
    else
      [{
        price_data: {
          currency: payment.currency,
          product_data: {
            name: payment.product_description,
            description: product_description_with_test_cards,
          },
          unit_amount: payment.amount_in_cents,
        },
        quantity: 1,
      }]
    end

    # Add test card info to all line items in development
    add_test_card_info_to_line_items(line_items)
  end

  def product_description_with_test_cards
    base_description = "Payment for #{payment.customer_name}"

    if Rails.env.development?
      test_info = " | TEST CARDS: 4242424242424242 | Any future expiry & CVC"
      base_description + test_info
    else
      base_description
    end
  end

  # Add test card info to all line items in development
  def add_test_card_info_to_line_items(line_items)
    return line_items unless Rails.env.development?

    line_items.map do |item|
      if item[:price_data] && item[:price_data][:product_data]
        product_data = item[:price_data][:product_data]

        # Add test card info to description if it exists
        if product_data[:description].present?
          test_info = " | TEST CARDS: 4242424242424242 | Any future expiry & CVC"
          product_data[:description] = product_data[:description] + test_info
        end
      end

      item
    end
  end

  # Determine payment mode (one-time vs subscription)
  # Automatically detects: payable.stripe_mode returns 'subscription' or 'payment'
  # Default: 'payment' (one-time purchase)
  def payment_mode
    payment.payable.respond_to?(:stripe_mode) ? payment.payable.stripe_mode : 'payment'
  end

  # Standard metadata for Stripe records
  # Contains all necessary info for tracking and customer support
  # Rarely needs customization
  def build_metadata
    {
      payment_id: payment.id,
      payable_type: payment.payable_type,
      payable_id: payment.payable_id,
      customer_email: payment.customer_email,
      customer_name: payment.customer_name
    }
  end

  # Webhook handlers
  def self.handle_checkout_success(checkout_session)
    payment = Payment.find_by(stripe_checkout_session_id: checkout_session['id'])
    return unless payment

    payment.update!(stripe_payment_intent_id: checkout_session['payment_intent']) if checkout_session['payment_intent']
    payment.mark_as_paid!
    Rails.logger.info "Checkout session completed for payment #{payment.id}"

    process_payment_paid(payment)
  end

  def self.handle_checkout_expiration(checkout_session)
    payment = Payment.find_by(stripe_checkout_session_id: checkout_session['id'])
    return unless payment

    payment.mark_as_canceled!
    Rails.logger.info "Checkout session expired for payment #{payment.id}"
  end

  def self.handle_payment_success(payment_intent)
    payment = Payment.find_by(stripe_payment_intent_id: payment_intent['id'])
    return unless payment

    payment.mark_as_paid!
    Rails.logger.info "Payment succeeded for payment #{payment.id}"

    process_payment_paid(payment)
  end

  def self.handle_payment_failure(payment_intent)
    payment = Payment.find_by(stripe_payment_intent_id: payment_intent['id'])
    return unless payment

    payment.mark_as_failed!
    Rails.logger.info "Payment failed for payment #{payment.id}"
  end

  def self.handle_payment_cancellation(payment_intent)
    payment = Payment.find_by(stripe_payment_intent_id: payment_intent['id'])
    return unless payment

    payment.mark_as_canceled!
    Rails.logger.info "Payment canceled for payment #{payment.id}"
  end

  # Handle subscription invoice payments (recurring billing)
  # CLACKY_NOTE: Only needed for subscription-based payments
  # If you're using subscriptions, implement this to create payment records for each billing cycle
  def self.handle_invoice_payment_success(invoice)
    subscription_id = invoice['subscription']
    return unless subscription_id

    # Example implementation (uncomment if using subscriptions):
    # subscription = Subscription.find_by(stripe_subscription_id: subscription_id)
    # return unless subscription
    #
    # subscription.payments.create!(
    #   amount: invoice['amount_paid'] / 100.0,
    #   currency: invoice['currency'],
    #   status: 'paid',
    #   stripe_payment_intent_id: invoice['payment_intent'],
    #   user: subscription.user,
    #   metadata: { invoice_id: invoice['id'], billing_cycle: Time.at(invoice['created']).to_date }
    # )

    Rails.logger.info "Invoice payment succeeded for subscription #{subscription_id}"
  end

  # CLACKY_NOTE: Only needed for subscription-based payments
  def self.handle_subscription_update(subscription)
    # Example: sync subscription status from Stripe
    # sub = Subscription.find_by(stripe_subscription_id: subscription['id'])
    # sub&.update!(
    #   status: subscription['status'],
    #   current_period_end: Time.at(subscription['current_period_end'])
    # )

    Rails.logger.info "Subscription updated: #{subscription['id']}"
  end

  # CLACKY_NOTE: Only needed for subscription-based payments
  def self.handle_subscription_deleted(subscription)
    # Example: mark subscription as canceled
    # sub = Subscription.find_by(stripe_subscription_id: subscription['id'])
    # sub&.update!(status: 'canceled')

    Rails.logger.info "Subscription deleted: #{subscription['id']}"
  end

  # CLACKY_TODO: Implement post-payment business logic
  # This is called after payment is confirmed as paid
  # Write your business logic here based on payable type
  #
  # Example:
  # case payment.payable_type
  # when 'Order'
  #   payment.payable.update!(status: 'paid')
  #   OrderMailer.confirmation(payment.payable).deliver_later
  # when 'Enrollment'
  #   payment.payable.update!(status: 'active')
  #   EnrollmentMailer.welcome(payment.payable).deliver_later
  # when 'Subscription'
  #   payment.payable.activate!
  # end
  def self.process_payment_paid(payment)
    Rails.logger.info "Payment #{payment.id} confirmed as paid for #{payment.payable_type} ##{payment.payable_id}"

    # TODO: Add your business logic here
  end
end
